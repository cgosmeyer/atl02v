
""" Module for sc/ verification class.

Author:

    C.M. Gosmeyer

Notes:

    Conversions in sc/hk are not from ITOS. Thare are from 
    DN-ICESat-2-SYS-024 (Rev C), "Orbital ATK ICESat-2 Design Note: Ancillary Telemetry Packet Description",
    primary author Jonah Skoog.
"""

import h5py
import numpy as np
import pylab as plt
from atl02qa.verification.verification_tools import Verify


class VerifySC(Verify):
    def __init__(self, vfiles, tolerance, atl02_dataset, path_out=''):
        atl02_dataset = 'sc/{}'.format(atl02_dataset)
        Verify.__init__(self, vfiles, tolerance, atl02_dataset, path_out)

    def __verify_single(self, custom_func):
        """
        """
        # Read the values from ATL02.
        atl02_values = self.atl02[self.atl02_dataset].value
        print("atl02_values: ", atl02_values)

        # Read the dataset to be compared against ATL02.
        verifier_values = custom_func()
        print("verifier_values: ", verifier_values)

        # Diff the arrays, plot diff, and record statistics.
        self.compare_arrays(atl02_values, verifier_values)

    def do_verify(self, custom_func):
        try:
            self.__verify_single(custom_func)
        except Exception as error:
            self.record_exception(error)


class VerifyOpticalHead(Verify):
    def __init__(self, vfiles, tolerance, atl02_dataset, path_out=''):
        Verify.__init__(self, vfiles, tolerance, atl02_dataset, path_out)

    def __verify_single(self, custom_func, num):
        """
        """
        # Create the base out name.
        self.base_filename = 'sc.star_tracker.optical_head_{}.{}'.format(num, self.atl02_dataset)

        # Read the values from ATL02.
        atl02_values = self.atl02['sc/star_tracker/optical_head_{}/{}'.format(num, self.atl02_dataset)].value
        print("atl02_values: ", atl02_values)

        # Read the dataset to be compared against ATL02.
        verifier_values = custom_func(num)
        print("verifier_values: ", verifier_values)

        # Diff the arrays, plot diff, and record statistics.
        self.compare_arrays(atl02_values, verifier_values)

    def do_verify(self, custom_func):
        for num in [1,2]:
            try:
                self.__verify_single(custom_func, num)
            except Exception as error:
                self.record_exception(error)

class VerifyGyro(Verify):
    def __init__(self, vfiles, tolerance, atl02_dataset, path_out=''):
        Verify.__init__(self, vfiles, tolerance, atl02_dataset, path_out)

    def __verify_single(self, custom_func, num):
        """
        """
        d = {0:'a', 1:'b', 2:'c', 3:'d'}

        # Create the base out name.
        self.base_filename = 'sc.inertial_measurement_unit.gyro_{}.{}'.format(d[num], self.atl02_dataset)

        # Read the values from ATL02.
        atl02_values = self.atl02['sc/inertial_measurement_unit/gyro_{}/{}'.format(d[num], self.atl02_dataset)].value
        print("atl02_values: ", atl02_values)

        # Read the dataset to be compared against ATL02.
        verifier_values = custom_func(num)
        print("verifier_values: ", verifier_values)

        # Diff the arrays, plot diff, and record statistics.
        self.compare_arrays(atl02_values, verifier_values)

    def do_verify(self, custom_func):
        for num in [0,1,2,3]:
            try:
                self.__verify_single(custom_func, num)
            except Exception as error:
                self.record_exception(error)


def calc_sync_event_ttag(raw_sync_event_ttag, raw_data_ttag, raw_sync_pulse_sec, raw_sync_pulse_subsec):
    """ To verify /sc/inertial_measurement_unit/sync_event_ttag.

    ASAS code
    ---------
    https://gs614wphoton.wff.nasa.gov/asas/atlas_l1b/sourcefile/process_sc_imu_mod.f90.html

    References
    ----------
    DN-ICESat-2-SYS-024
    Emails from JLee on 15 Oct 2019
    """

    # These represent SC time at instant the event strobe was sent to the IMU.
    # This occurs once every 10 seconds.

    # raw_sync_pulse_sec (10 Hz) units of sec

    # raw_sync_pulse_subsec (10 Hz) units of 100 ns


    # These are generated by the IMU.

    # raw_sync_event_ttag (50 Hz)
    #   * Normally reports value of -32768.
    #   * Once every 10 seconds, when the SC sends the event strobe to the IMU, 
    #     will update with IMU IDL countdown timer value.
    # raw_data_ttag (50 Hz)


    # T_IMU_valid = snyc_pulse_sec +sync_pulse_subsec+ sync_event_timetag + T_IMU_cal
    # sync_event_timetag = sync_event_timetag (at event strobe) + (data_timetag_this sample â€“ data_timetag_base)
    # Where T_IMU_cal = -0.1 seconds  (-0.1 seconds is the current estimate of the delay)

    # These are SC Time at the instant when when the synchronization event 
    # strobe was sent by the IEM UDL to the IMU
    raw_sync_pulse_sec = raw_sync_pulse_sec.T.flatten()
    raw_sync_pulse_subsec = raw_sync_pulse_subsec.T.flatten()

    T_IMU_cal = -0.1

    # To keep track of seconds.
    isec = 0

    for i in range(len(raw_sync_event_ttag)):
        # value of the raw_data_ttag when raw_sync_event_timetag is valid
        data_timetag_base = 0 

        T_SC_S = raw_sync_pulse_sec[isec] + raw_sync_pulse_subsec[isec]*100e-9 

        # How determine whether new strobe?
        if raw_sync_event_ttag[i] == -32768:
            new_strobe = False
        else:
            new_strobe = True


        if new_strobe:
            T_IMU_S = raw_sync_event_ttag[i]*333.33e-09
            T_IMU_valid = T_SC_S + T_IMU_S
            # This only occurs on new strobe.
            # number of seconds increases by 10 each new strobe.
            # so increase the index by 1, since the second arrays are at 10 Hz.
            isec += 1

        elif not new_strobe:
            T_IMU_S = raw_sync_event_ttag[i]*333.33e-09
            T_IMU_DATA = raw_data_ttag[i]*4.0e-06 - data_timetag_base
            T_IMU_valid = T_SC_S + T_IMU_S + T_IMU_DATA + T_IMU_cal

            data_timetag_base = T_IMU_S

